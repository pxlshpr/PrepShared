import Foundation

public struct Goal: Identifiable, Hashable, Codable {
    
    public let type: GoalType
    public var bound: GoalBound
    public var isAutoGenerated: Bool
    public var calculatedBound: GoalBound
    public var calculatedAt: Date
    
    public init(
        type: GoalType,
        bound: GoalBound,
        isAutoGenerated: Bool = false,
        calculatedBound: GoalBound,
        calculatedAt: Date = Date.now
    ) {
        self.type = type
        self.bound = bound
        self.isAutoGenerated = isAutoGenerated
        self.calculatedBound = calculatedBound
        self.calculatedAt = calculatedAt
    }
}

extension Goal: Comparable {
    var sortPosition: Int {
        switch type {
        case .energy:                   1
        case .macro(_, let macro):      macro.sortPosition
        case .micro(_, let micro, _):   micro.rawValue
        }
    }
    public static func <(lhs: Goal, rhs: Goal) -> Bool {
        return lhs.sortPosition < rhs.sortPosition
    }
}
public extension Goal {
    var id: String {
        type.identifyingHashValue
    }
    
//    var unit: any BiometricUnit {
//        switch type {
//        case .energy(let type):
//            switch type {
//            case .fixed(let unit):
//                unit
//            case .fromMaintenance(let unit, _):
//                unit
//            case .percentFromMaintenance:
//                SettingsStore.shared.settings.energyUnit
//            }
//        case .macro:
//            NutrientUnit.g
//        case .micro(_, _, let unit):
//            unit
//        }
//    }
}

public extension Array where Element == Goal {
    var micros: [Micro] {
        self.compactMap { $0.type.micro }
    }
    
    var macros: [Macro] {
        self.compactMap { $0.type.macro }
    }
    
    var containsEnergyGoal: Bool {
        self.contains(where: { $0.type.isEnergy })
    }
    
    var manualEnergyGoal: Goal? {
        first(where: { $0.type.isEnergy && !$0.isAutoGenerated })
    }
    
    var manualMacroGoals: [Goal] {
        filter { $0.type.isMacro && !$0.isAutoGenerated }
    }

    var allMacroGoalsAreClosed: Bool {
        manualMacroGoals.allSatisfy { $0.calculatedBound.type == .closed }
    }

    var allMacroGoalsHaveUpper: Bool {
        manualMacroGoals.allSatisfy { $0.calculatedBound.upper != nil }
    }

    var allMacroGoalsHaveLower: Bool {
        manualMacroGoals.allSatisfy { $0.calculatedBound.lower != nil }
    }

    var supportsOrHasAutoEnergyGoal: Bool {
        supportsAutoEnergyGoal || hasAutoEnergyGoal
    }
    
    var hasManualEnergyGoal: Bool {
        manualEnergyGoal != nil
    }

    var supportsAutoEnergyGoal: Bool {
        !hasManualEnergyGoal
        && manualMacroGoals.count == 3
        && (allMacroGoalsAreClosed || allMacroGoalsHaveLower || allMacroGoalsHaveUpper)
    }
    
    var hasAutoEnergyGoal: Bool {
        contains(where: { $0.type.isEnergy && $0.isAutoGenerated })
    }

    var missingMacro: Macro? {
        guard manualMacroGoals.count == 2 else { return nil }
        let macros = manualMacroGoals.compactMap { $0.type.macro }
        return Set(Macro.allCases).subtracting(Set(macros)).first
    }
    
    var autoMacroGoal: Goal? {
        first(where: { $0.type.isMacro && $0.isAutoGenerated })
    }

    var macrosWithGoals: [Macro] {
        compactMap { $0.type.macro }
            .removingDuplicates()
    }

    var hasAutoMacroGoal: Bool {
        autoMacroGoal != nil
    }
    
    var supportsOrHasAutoMacroGoal: Bool {
        macroForAutoGoal != nil || hasAutoMacroGoal
    }

    var supportsAutoMacroGoal: Bool {
        macroForAutoGoal != nil
    }

    var numberOfEnergyDependentGoals: Int {
        filter { $0.type.usesEnergyGoal }.count
    }
    
    var hasEnergyDependentGoals: Bool {
        numberOfEnergyDependentGoals > 0
    }

    var macroForAutoGoal: Macro? {
        
        guard !hasAutoMacroGoal else { return nil }
        
        /// Otherwise determine if there is a potential macro for an auto goal
        guard hasManualEnergyGoal else { return nil }
        let macros = macrosWithGoals
        guard macros.count == 2 else { return nil }
        return Set(Macro.allCases)
            .subtracting(Set(macros))
            .first
    }
    
    func lowerMissingMacro(for energyGoal: Goal) -> Double? {
        guard
            let missingMacro,
            let energyUnit = energyGoal.type.energyUnit,
            let energyValue = energyGoal.bound.lower ?? energyGoal.bound.upper
        else { return nil }
        
        let e = energyUnit.convert(energyValue, to: .kcal)
        
        switch missingMacro {
        case .carb:
            guard let fatBound, let proteinBound else { return nil }
            let f = fatBound.lower ?? 0
            let p = proteinBound.lower ?? 0
            return (e - (
                (f * Macro.fat.kcalsPerGram)
                + (p * Macro.protein.kcalsPerGram)
            )) / Macro.carb.kcalsPerGram
            
        case .protein:
            guard let fatBound, let carbBound else { return nil }
            let f = fatBound.lower ?? 0
            let c = carbBound.lower ?? 0
            return (e - (
                (f * Macro.fat.kcalsPerGram)
                + (c * Macro.carb.kcalsPerGram)
            )) / Macro.protein.kcalsPerGram
            
        case .fat:
            guard let proteinBound, let carbBound else { return nil }
            let p = proteinBound.lower ?? 0
            let c = carbBound.lower ?? 0
            return (e - (
                (p * Macro.protein.kcalsPerGram)
                + (c * Macro.carb.kcalsPerGram)
            )) / Macro.fat.kcalsPerGram
        }
    }

    func upperMissingMacro(for energyGoal: Goal) -> Double? {
        guard
            let missingMacro,
            let energyUnit = energyGoal.type.energyUnit,
            let energyValue = energyGoal.bound.upper ?? energyGoal.bound.lower
        else { return nil }
        
        let e = energyUnit.convert(energyValue, to: .kcal)
        
        switch missingMacro {
        case .carb:
            guard
                let fatBound,
                let proteinBound,
                let f = fatBound.upper ?? fatBound.lower,
                let p = proteinBound.upper ?? proteinBound.lower
            else { return nil }
            
            return (e - (
                (f * Macro.fat.kcalsPerGram)
                + (p * Macro.protein.kcalsPerGram)
            )) / Macro.carb.kcalsPerGram
            
        case .protein:
            guard
                let fatBound,
                let carbBound,
                let f = fatBound.upper ?? fatBound.lower,
                let c = carbBound.upper ?? carbBound.lower
            else { return nil }
            
            return (e - (
                (f * Macro.fat.kcalsPerGram)
                + (c * Macro.carb.kcalsPerGram)
            )) / Macro.protein.kcalsPerGram
            
        case .fat:
            guard
                let proteinBound,
                let carbBound,
                let p = proteinBound.upper ?? proteinBound.lower,
                let c = carbBound.upper ?? carbBound.lower
            else { return nil }
            
            return (e - (
                (p * Macro.protein.kcalsPerGram)
                + (c * Macro.carb.kcalsPerGram)
            )) / Macro.fat.kcalsPerGram
        }
    }

    var lowerEnergyInKcal: Double? {
        guard let carbBound, let fatBound, let proteinBound else { return nil }

        let c = carbBound.lower ?? 0
        let f = fatBound.lower ?? 0
        let p = proteinBound.lower ?? 0

        return (c * Macro.carb.kcalsPerGram)
        + (f * Macro.fat.kcalsPerGram)
        + (p * Macro.protein.kcalsPerGram)
    }
    
    var upperEnergyInKcal: Double? {
        guard let carbBound, let fatBound, let proteinBound else { return nil }

        let c = carbBound.upper ?? 0
        let f = fatBound.upper ?? 0
        let p = proteinBound.upper ?? 0

        return (c * Macro.carb.kcalsPerGram)
        + (f * Macro.fat.kcalsPerGram)
        + (p * Macro.protein.kcalsPerGram)
    }

    var upperOrLowerEnergyInKcal: Double? {
        guard
            let c = carbUpperOrLower,
            let f = fatUpperOrLower,
            let p = proteinUpperOrLower
        else {
            return nil
        }
        
        return (c * Macro.carb.kcalsPerGram)
        + (f * Macro.fat.kcalsPerGram)
        + (p * Macro.protein.kcalsPerGram)
    }

    var carbUpperOrLower: Double? { carbBound?.upper ?? carbBound?.lower }
    var fatUpperOrLower: Double? { fatBound?.upper ?? fatBound?.lower }
    var proteinUpperOrLower: Double? { proteinBound?.upper ?? proteinBound?.lower }

    var carbBound: GoalBound? { bound(for: .carb) }
    var fatBound: GoalBound? { bound(for: .fat) }
    var proteinBound: GoalBound? { bound(for: .protein) }

    func bound(for macro: Macro) -> GoalBound? {
        first(where: { $0.type.macro == macro })?.calculatedBound
    }
}
