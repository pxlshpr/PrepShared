import Foundation

public struct PlanFields: Hashable, Equatable {
    public var name: String
    public var emoji: String
    public var goals: [Goal]
    
    public init(
        name: String = "",
        emoji: String = String.randomPlanEmoji,
        goals: [Goal] = []
    ) {
        self.name = name
        self.emoji = emoji
        self.goals = goals
    }
    
    public init(_ plan: Plan) {
        self.init()
        self.fill(with: plan)
    }
}

public extension PlanFields {
    var canBeSaved: Bool {
        !name.isEmpty
        && !emoji.isEmpty
        && !goals.isEmpty
    }
    
    mutating func fill(with plan: Plan) {
        name = plan.name
        emoji = plan.emoji
        goals = plan.goals
    }
}

public extension PlanFields {
    func indexOfGoal(matching goal: Goal) -> Int? {
        goals.firstIndex(where: { $0.type.nutrient == goal.type.nutrient })
    }
    
    mutating func save(_ goal: Goal) {
        if let index = indexOfGoal(matching: goal) {
            goals[index] = goal
        } else {
            goals.append(goal)
        }
        resetAutoGoal()
    }
    
    mutating func delete(_ goal: Goal) {
        if goal.type.isEnergy {
            goals.removeAll(where: { $0.type.usesEnergyGoal })
        }
        goals.removeAll(where: { $0.type.nutrient == goal.type.nutrient })
        resetAutoGoal()
    }
}

public extension PlanFields {
    var haveMicros: Bool {
        goals.contains(where: { $0.type.isMicro })
    }
    
    var haveMacros: Bool {
        goals.contains(where: { $0.type.isMacro })
    }
    
    var hasEnergy: Bool {
        goals.contains(where: { $0.type.isEnergy })
    }
}

public extension Plan {
    func matches(_ fields: PlanFields) -> Bool {
        if fields.name != name { return false }
        if fields.emoji != emoji { return false }
        return true
    }
}

public extension PlanFields {
    
    var allMacroGoalsAreClosed: Bool {
        goals.allMacroGoalsAreClosed
    }

    var allMacroGoalsHaveUpper: Bool {
        goals.allMacroGoalsHaveUpper
    }

    var allMacroGoalsHaveLower: Bool {
        goals.allMacroGoalsHaveLower
    }

    func generatedAutoMacroGoal() -> Goal? {
        goals.generatedAutoMacroGoal()
    }
}

public extension PlanFields {
    func generatedAutoEnergyGoal(using unit: EnergyUnit) -> Goal? {
        goals.generatedAutoEnergyGoal(using: unit)
    }
}

public extension Array where Element == Goal {
    func generatedAutoEnergyGoal(using unit: EnergyUnit) -> Goal? {
        
        /// Gather all macro goals
        guard manualMacroGoals.count == 3 else { return nil }

        let bound: GoalBound
        if allMacroGoalsAreClosed {
            
            guard
                let lowerInKcal = manualMacroGoals.lowerEnergyInKcal,
                let upperInKcal = manualMacroGoals.upperOrLowerEnergyInKcal
            else {
                return nil
            }
            
            let lower = EnergyUnit.kcal.convert(lowerInKcal, to: unit)
            let upper = EnergyUnit.kcal.convert(upperInKcal, to: unit)
            
            guard let energyBound = GoalBound(.closed, lower, upper) else {
                return nil
            }
            bound = energyBound
        } else if allMacroGoalsHaveUpper {
            bound = GoalBound(upper: manualMacroGoals.upperEnergyInKcal)
        } else if allMacroGoalsHaveLower {
            bound = GoalBound(lower: manualMacroGoals.lowerEnergyInKcal)
        } else {
            return nil
        }

        return Goal(
            type: .energy(.fixed(unit)),
            bound: bound,
            isAutoGenerated: true,
            calculatedBound: bound,
            calculatedAt: Date.now
        )
    }
}

public extension PlanFields {

    var manualMacroGoals: [Goal] {
        goals.manualMacroGoals
    }

    var manualMicroGoals: [Goal] {
        goals
            .filter { $0.type.isMicro }
            .filter { !$0.isAutoGenerated }
    }
    
    var showGoalsHeaderOnMicros: Bool {
        !hasEnergy && !haveMacros && haveMicros
    }
    
    var showGoalsHeaderOnMacros: Bool {
        !hasEnergy && !supportsOrHasAutoEnergyGoal && haveMacros
    }
    
    var showGoalsHeaderOnEnergy: Bool {
        hasEnergy || supportsOrHasAutoEnergyGoal
    }
    
    var showGoalsHeaderOnAdd: Bool {
        goals.isEmpty
    }
}

public extension PlanFields {
    var energyGoal: Goal? { goals.energyGoal }
    var manualEnergyGoal: Goal? { goals.manualEnergyGoal }
    var autoEnergyGoal: Goal? { goals.autoEnergyGoal }
    var numberOfEnergyDependentGoals: Int { goals.numberOfEnergyDependentGoals }
    var hasEnergyDependentGoals: Bool { goals.hasEnergyDependentGoals }
    var autoMacroGoal: Goal? { goals.autoMacroGoal }
    var hasAutoMacroGoal: Bool { goals.hasAutoMacroGoal }
    var macrosWithGoals: [Macro] { goals.macrosWithGoals }
    var hasManualEnergyGoal: Bool { goals.hasManualEnergyGoal }
    var supportsOrHasAutoEnergyGoal: Bool { goals.supportsOrHasAutoEnergyGoal }
    var supportsAutoEnergyGoal: Bool { goals.supportsAutoEnergyGoal }
    var hasAutoEnergyGoal: Bool { goals.hasAutoEnergyGoal }
    var supportsAutoMacroGoal: Bool { goals.supportsAutoMacroGoal }
    var macroForAutoGoal: Macro? { goals.macroForAutoGoal }
    var supportsOrHasAutoMacroGoal: Bool { goals.supportsOrHasAutoMacroGoal }
}

import SwiftUI

public extension PlanFields {
    mutating func removeAutoGoal() {
        withAnimation {
            goals.removeAll(where: { $0.isAutoGenerated })
        }
    }
    
    mutating func addAutoGoal(for macro: Macro) {
        guard let goal = generatedAutoMacroGoal() else { return }
        withAnimation {
            goals.append(goal)
        }
    }
    
    mutating func addAutoGoalForEnergy(using unit: EnergyUnit) {
        guard let goal = generatedAutoEnergyGoal(using: unit) else { return }
        withAnimation {
            goals.append(goal)
        }
    }
    
    func regenerateAutoGoal(_ goal: Goal) -> Goal? {
        guard goal.isAutoGenerated else { return nil }

        if goal.type.isEnergy {
            guard let energyUnit = goal.type.energyUnit else { return nil }
            return generatedAutoEnergyGoal(using: energyUnit)

        } else if goal.type.isMacro {
            return generatedAutoMacroGoal()

        } else {
            return nil
        }
    }
    
    mutating func resetAutoGoal() {
        /// If we have an auto goal
        guard let autoGoal, let autoGoalIndex else { return }

        /// Check if it's still compatible (if we still have all the required goals)
        if autoGoal.autoGoalIsCompatible(with: goals) {
            /// If so, regenerate it
            guard let new = regenerateAutoGoal(autoGoal) else { return }
            withAnimation {
                goals[autoGoalIndex] = new
            }
            
        } else {
            /// Otherwise, remove the auto goal
            withAnimation {
                let _ = goals.remove(at: autoGoalIndex)
            }
        }
    }
}

extension Goal {
    func autoGoalIsCompatible(with goals: [Goal]) -> Bool {
        guard isAutoGenerated else { return false }
        
        return if type.isEnergy {   goals.supportsAutoEnergyGoal
        } else if type.isMacro {    goals.supportsAutoMacroGoal
        } else {                    false
        }
    }
}

public extension PlanFields {
    var autoGoal: Goal? {
        goals.first(where: { $0.isAutoGenerated })
    }
    
    var autoGoalIndex: Int? {
        goals.firstIndex(where: { $0.isAutoGenerated })
    }
}
