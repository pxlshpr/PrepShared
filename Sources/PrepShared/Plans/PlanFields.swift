import Foundation

public struct PlanFields: Hashable, Equatable {
    public var name: String
    public var emoji: String
    public var goals: [Goal]
    
    public init(
        name: String = "",
        emoji: String = String.randomPlanEmoji,
        goals: [Goal] = []
    ) {
        self.name = name
        self.emoji = emoji
        self.goals = goals
    }
    
    public init(_ plan: Plan) {
        self.init()
        self.fill(with: plan)
    }
}

public extension PlanFields {
    var canBeSaved: Bool {
        !name.isEmpty
        && !emoji.isEmpty
        && !goals.isEmpty
    }
    
    mutating func fill(with plan: Plan) {
        name = plan.name
        emoji = plan.emoji
        goals = plan.goals
    }
}

public extension PlanFields {
    var manualEnergyGoal: Goal? {
        goals.first(where: { $0.type.isEnergy && !$0.isAutoGenerated })
    }

    /// Returns the auto energy goal if present
    var autoEnergyGoal: Goal? {
        goals.first(where: { $0.type.isEnergy && $0.isAutoGenerated })
    }

    func indexOfGoal(matching goal: Goal) -> Int? {
        goals.firstIndex(where: { $0.type.nutrient == goal.type.nutrient })
    }
    
    mutating func save(_ goal: Goal) {
        if let index = indexOfGoal(matching: goal) {
            goals[index] = goal
        } else {
            goals.append(goal)
        }
        resetAutoGoal()
    }
    
    mutating func delete(_ goal: Goal) {
        if goal.type.isEnergy {
            goals.removeAll(where: { $0.type.usesEnergyGoal })
        }
        goals.removeAll(where: { $0.type.nutrient == goal.type.nutrient })
        resetAutoGoal()
    }
}

public extension PlanFields {
    var haveMicros: Bool {
        goals.contains(where: { $0.type.isMicro })
    }
    
    var haveMacros: Bool {
        goals.contains(where: { $0.type.isMacro })
    }
    
    var hasEnergy: Bool {
        goals.contains(where: { $0.type.isEnergy })
    }
}

public extension Plan {
    func matches(_ fields: PlanFields) -> Bool {
        if fields.name != name { return false }
        if fields.emoji != emoji { return false }
        return true
    }
}

public extension PlanFields {
    
    var haveClosedMacroGoal: Bool {
        manualMacroGoals.contains(where: { $0.calculatedBound.type == .closed })
    }

    var allMacroGoalsAreClosed: Bool {
        manualMacroGoals.allSatisfy { $0.calculatedBound.type == .closed }
    }

    var allMacroGoalsHaveUpper: Bool {
        manualMacroGoals.allSatisfy { $0.calculatedBound.upper != nil }
    }

    var allMacroGoalsHaveLower: Bool {
        manualMacroGoals.allSatisfy { $0.calculatedBound.lower != nil }
    }

    var haveLowerMacroGoal: Bool {
        manualMacroGoals.contains(where: { $0.calculatedBound.type == .lower })
    }

    func generatedAutoMacroGoal() -> Goal? {
        /// Gather 2 macro goals and energy goal
        guard
            let manualEnergyGoal,
            manualMacroGoals.count == 2,
            let missingMacro = manualMacroGoals.missingMacro
        else { return nil }

        let bound: GoalBound
        
        if haveClosedMacroGoal {
            
            guard
                let lower = manualMacroGoals.lowerMissingMacro(for: manualEnergyGoal),
                let upper = manualMacroGoals.upperMissingMacro(for: manualEnergyGoal)
            else {
                return nil
            }
            bound = GoalBound(lower: lower, upper: upper)

        } else {
            return nil
        }
        
        return Goal(
            type: .macro(.fixed, missingMacro),
            bound: bound,
            isAutoGenerated: true,
            calculatedBound: bound,
            calculatedAt: Date.now
        )
        /// If any of them have a closed bound, we're creating a closed bound goal
        /// - What do we do if some are lower and some are upper? (Macro follows energy)
        ///     - 2 macros upper, energy lower: macro lower
        ///     - 1 macro + energy upper, 1 macro lower: macro upper
        ///     - energy upper, 2 macro lower: macro upper
        ///     - all 3 upper: macro upper
        ///     - all 3 lower: macro lower
        /// - Now calculate the goals
        
    }
}

public extension PlanFields {
    func generatedAutoEnergyGoal(using unit: EnergyUnit) -> Goal? {
        
        /// Gather all macro goals
        guard manualMacroGoals.count == 3 else { return nil }

        let bound: GoalBound
        if allMacroGoalsAreClosed {
            
            guard
                let lowerInKcal = manualMacroGoals.lowerEnergyInKcal,
                let upperInKcal = manualMacroGoals.upperOrLowerEnergyInKcal
            else {
                return nil
            }
            
            let lower = EnergyUnit.kcal.convert(lowerInKcal, to: unit)
            let upper = EnergyUnit.kcal.convert(upperInKcal, to: unit)
            
            guard let energyBound = GoalBound(.closed, lower, upper) else {
                return nil
            }
            bound = energyBound
        } else if allMacroGoalsHaveUpper {
            bound = GoalBound(upper: manualMacroGoals.upperEnergyInKcal)
        } else if allMacroGoalsHaveLower {
            bound = GoalBound(lower: manualMacroGoals.lowerEnergyInKcal)
        } else {
            return nil
//        } else {
//            
//            
//            
//            let upperCount = manualMacroGoals.filter {
//                $0.calculatedBound.upper != nil
//            }.count
//            let lowerCount = manualMacroGoals.filter {
//                $0.calculatedBound.lower != nil
//            }.count
//            
//            /// Set a maximum for energy only if all macros are also maximum. Otherwise, set a minimum with a total of any minimum bounds.
//            switch (upperCount, lowerCount) {
//            case (3, 0):    bound = GoalBound(upper: manualMacroGoals.upperEnergyInKcal)
//            default:        bound = GoalBound(lower: manualMacroGoals.lowerEnergyInKcal)
//            }
        }

        return Goal(
            type: .energy(.fixed(unit)),
            bound: bound,
            isAutoGenerated: true,
            calculatedBound: bound,
            calculatedAt: Date.now
        )
    }
}

public extension PlanFields {

    var manualMacroGoals: [Goal] {
        goals.manualMacroGoals
    }

    var manualMicroGoals: [Goal] {
        goals
            .filter { $0.type.isMicro }
            .filter { !$0.isAutoGenerated }
    }
    
    var showGoalsHeaderOnMicros: Bool {
        !hasEnergy && !haveMacros && haveMicros
    }
    
    var showGoalsHeaderOnMacros: Bool {
        !hasEnergy && !supportsOrHasAutoEnergyGoal && haveMacros
    }
    
    var showGoalsHeaderOnEnergy: Bool {
        hasEnergy || supportsOrHasAutoEnergyGoal
    }
    
    var showGoalsHeaderOnAdd: Bool {
        goals.isEmpty
    }
}

public extension PlanFields {
    
    var numberOfEnergyDependentGoals: Int {
        goals.filter { $0.type.usesEnergyGoal }.count
    }
    
    var hasEnergyDependentGoals: Bool {
        numberOfEnergyDependentGoals > 0
    }
}

public extension PlanFields {
    
    var autoMacroGoal: Goal? {
        goals.first(where: { $0.type.isMacro && $0.isAutoGenerated })
    }
    var hasAutoMacroGoal: Bool {
        autoMacroGoal != nil
    }

    var macrosWithGoals: [Macro] {
        goals
            .compactMap { $0.type.macro }
            .removingDuplicates()
    }
    
    var hasManualEnergyGoal: Bool {
        manualEnergyGoal != nil
    }

    var supportsOrHasAutoEnergyGoal: Bool {
        supportsAutoEnergyGoal || hasAutoEnergyGoal
    }
    
    var supportsAutoEnergyGoal: Bool {
        !hasManualEnergyGoal
        && manualMacroGoals.count == 3
        && (allMacroGoalsAreClosed || allMacroGoalsHaveLower || allMacroGoalsHaveUpper)
    }
    
    var hasAutoEnergyGoal: Bool {
        goals
            .contains(where: { $0.type.isEnergy && $0.isAutoGenerated })
    }
    
    var supportsAutoMacroGoal: Bool {
        macroForAutoGoal != nil
    }
    
    var macroForAutoGoal: Macro? {
        
        /// Return the macro for the existing auto goal, if present
        if let macro = autoMacroGoal?.type.macro {
            return macro
        }
        
        /// Otherwise determine if there is a potential macro for an auto goal
        guard hasManualEnergyGoal else { return nil }
        let macros = macrosWithGoals
        guard macros.count == 2 else { return nil }
        return Set(Macro.allCases)
            .subtracting(Set(macros))
            .first
    }
}

import SwiftUI

public extension PlanFields {
    mutating func removeAutoGoal() {
        withAnimation {
            goals.removeAll(where: { $0.isAutoGenerated })
        }
    }
    
    mutating func addAutoGoal(for macro: Macro) {
        guard let goal = generatedAutoMacroGoal() else { return }
        withAnimation {
            goals.append(goal)
        }
    }
    
    mutating func addAutoGoalForEnergy(using unit: EnergyUnit) {
        guard let goal = generatedAutoEnergyGoal(using: unit) else { return }
        withAnimation {
            goals.append(goal)
        }
    }
    
    func regenerateAutoGoal(_ goal: Goal) -> Goal? {
        guard goal.isAutoGenerated else { return nil }

        if goal.type.isEnergy {
            guard let energyUnit = goal.type.energyUnit else { return nil }
            return generatedAutoEnergyGoal(using: energyUnit)

        } else if goal.type.isMacro {
            return generatedAutoMacroGoal()

        } else {
            return nil
        }
    }
    
    mutating func resetAutoGoal() {
        /// If we have an auto goal
        guard let autoGoal, let autoGoalIndex else { return }

        /// Check if it's still compatible (if we still have all the required goals)
        if autoGoal.autoGoalIsCompatible(with: goals) {
            /// If so, regenerate it
            guard let new = regenerateAutoGoal(autoGoal) else { return }
            withAnimation {
                goals[autoGoalIndex] = new
            }
            
        } else {
            /// Otherwise, remove the auto goal
            withAnimation {
                let _ = goals.remove(at: autoGoalIndex)
            }
        }
    }
}

extension Goal {
    func autoGoalIsCompatible(with goals: [Goal]) -> Bool {
        guard isAutoGenerated else { return false }
        
        if type.isEnergy {
            return goals.manualMacroGoals.count == 3
            
        } else if type.isMacro {
            guard goals.containsManualEnergyGoal else { return false }
            return goals.manualMacroGoals.count == 2
            
        } else {
            return false
        }
    }
}

public extension PlanFields {
    var autoGoal: Goal? {
        goals.first(where: { $0.isAutoGenerated })
    }
    
    var autoGoalIndex: Int? {
        goals.firstIndex(where: { $0.isAutoGenerated })
    }
}
